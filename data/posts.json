[
  {
    "id": "getting-started-computer-vision",
    "title": "Getting Started with Computer Vision",
    "date": "2025-02-20",
    "author": "Emin",
    "tags": ["computer-vision", "python", "opencv", "ai"],
    "excerpt": "An introduction to computer vision concepts and practical applications using Python and OpenCV.",
    "html": "<p>Computer vision is a fascinating field that enables machines to interpret and understand visual information from the world. In this comprehensive guide, we'll explore the fundamental concepts and practical applications that make computer vision such an exciting area of artificial intelligence.</p><h2>What is Computer Vision?</h2><p>Computer vision is a multidisciplinary field that deals with how computers can gain high-level understanding from digital images or videos. From the perspective of engineering, it seeks to automate tasks that the human visual system can do.</p><h2>Key Applications</h2><p>Computer vision has numerous real-world applications including:</p><ul><li><strong>Autonomous Vehicles:</strong> Self-driving cars use computer vision to detect lanes, pedestrians, and traffic signs</li><li><strong>Medical Imaging:</strong> Doctors use computer vision to detect diseases from X-rays, MRIs, and other medical scans</li><li><strong>Security Systems:</strong> Facial recognition and object detection for surveillance</li><li><strong>Augmented Reality:</strong> Overlaying digital information on the real world</li></ul><h2>Getting Started with Python and OpenCV</h2><p>Python is the most popular language for computer vision due to its simplicity and extensive libraries. OpenCV (Open Source Computer Vision Library) is the go-to library for computer vision tasks.</p><pre><code class=\"language-python\">import cv2\nimport numpy as np\n\n# Read an image\nimg = cv2.imread('image.jpg')\n\n# Convert to grayscale\ngray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n# Display the image\ncv2.imshow('Image', gray)\ncv2.waitKey(0)\ncv2.destroyAllWindows()</code></pre><p>This simple example demonstrates how to load, process, and display images using OpenCV. The library provides hundreds of functions for image processing, feature detection, and machine learning integration.</p><h2>Next Steps</h2><p>To dive deeper into computer vision, I recommend exploring:</p><ul><li>Image filtering and transformations</li><li>Feature detection and matching</li><li>Object detection using deep learning</li><li>Real-time video processing</li></ul><p>Computer vision is a rapidly evolving field with endless possibilities. Whether you're interested in robotics, healthcare, or creative applications, there's always something new to learn and explore.</p>"
  },
  {
    "id": "building-rest-api-go",
    "title": "Building a REST API with Go",
    "date": "2025-02-15",
    "author": "Emin",
    "tags": ["go", "api", "web-development", "backend"],
    "excerpt": "Learn how to create a robust REST API using Go, including authentication, validation, and testing.",
    "html": "<p>Go (Golang) has become one of the most popular languages for building web services and APIs. Its simplicity, performance, and built-in concurrency support make it an excellent choice for backend development. In this post, we'll explore how to build a production-ready REST API using Go.</p><h2>Why Go for APIs?</h2><p>Go offers several advantages for API development:</p><ul><li><strong>Performance:</strong> Near C-level performance with garbage collection</li><li><strong>Concurrency:</strong> Built-in goroutines and channels for handling multiple requests</li><li><strong>Simplicity:</strong> Clean, readable syntax that's easy to maintain</li><li><strong>Standard Library:</strong> Rich standard library with excellent HTTP support</li><li><strong>Cross-platform:</strong> Single binary that runs anywhere</li></ul><h2>Basic API Structure</h2><p>Here's a simple example of a Go REST API:</p><pre><code class=\"language-go\">package main\n\nimport (\n    \"encoding/json\"\n    \"log\"\n    \"net/http\"\n    \"github.com/gorilla/mux\"\n)\n\ntype User struct {\n    ID    string `json:\"id\"`\n    Name  string `json:\"name\"`\n    Email string `json:\"email\"`\n}\n\nfunc main() {\n    r := mux.NewRouter()\n    \n    // Routes\n    r.HandleFunc(\"/api/users\", getUsers).Methods(\"GET\")\n    r.HandleFunc(\"/api/users/{id}\", getUser).Methods(\"GET\")\n    r.HandleFunc(\"/api/users\", createUser).Methods(\"POST\")\n    \n    log.Fatal(http.ListenAndServe(\":8080\", r))\n}\n\nfunc getUsers(w http.ResponseWriter, r *http.Request) {\n    users := []User{\n        {ID: \"1\", Name: \"John Doe\", Email: \"john@example.com\"},\n        {ID: \"2\", Name: \"Jane Smith\", Email: \"jane@example.com\"},\n    }\n    \n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(users)\n}</code></pre><h2>Adding Middleware</h2><p>Middleware is essential for adding cross-cutting concerns like authentication, logging, and CORS:</p><pre><code class=\"language-go\">func loggingMiddleware(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        log.Printf(\"%s %s\", r.Method, r.URL.Path)\n        next.ServeHTTP(w, r)\n    })\n}\n\nfunc corsMiddleware(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n        w.Header().Set(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE, OPTIONS\")\n        w.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n        \n        if r.Method == \"OPTIONS\" {\n            w.WriteHeader(http.StatusOK)\n            return\n        }\n        \n        next.ServeHTTP(w, r)\n    })\n}</code></pre><h2>Testing Your API</h2><p>Go has excellent built-in testing support. Here's how to test your API endpoints:</p><pre><code class=\"language-go\">func TestGetUsers(t *testing.T) {\n    req, err := http.NewRequest(\"GET\", \"/api/users\", nil)\n    if err != nil {\n        t.Fatal(err)\n    }\n    \n    rr := httptest.NewRecorder()\n    handler := http.HandlerFunc(getUsers)\n    handler.ServeHTTP(rr, req)\n    \n    if status := rr.Code; status != http.StatusOK {\n        t.Errorf(\"handler returned wrong status code: got %v want %v\", status, http.StatusOK)\n    }\n    \n    expected := `[{\"id\":\"1\",\"name\":\"John Doe\",\"email\":\"john@example.com\"}]`\n    if rr.Body.String() != expected {\n        t.Errorf(\"handler returned unexpected body: got %v want %v\", rr.Body.String(), expected)\n    }\n}</code></pre><h2>Production Considerations</h2><p>When deploying your Go API to production, consider:</p><ul><li><strong>Environment Configuration:</strong> Use environment variables for configuration</li><li><strong>Logging:</strong> Implement structured logging with levels</li><li><strong>Metrics:</strong> Add Prometheus metrics for monitoring</li><li><strong>Health Checks:</strong> Implement health check endpoints</li><li><strong>Rate Limiting:</strong> Protect your API from abuse</li></ul><p>Go's simplicity and performance make it an excellent choice for building REST APIs. With proper structure, middleware, and testing, you can create robust, scalable services that are easy to maintain and deploy.</p>"
  },
  {
    "id": "react-hooks-deep-dive",
    "title": "React Hooks Deep Dive",
    "date": "2025-02-10",
    "author": "Emin",
    "tags": ["react", "javascript", "frontend", "hooks"],
    "excerpt": "Understanding React Hooks from basics to advanced patterns for state management and side effects.",
    "html": "<p>React Hooks have revolutionized how we write functional components in React. Introduced in React 16.8, hooks allow you to use state and other React features without writing class components. In this deep dive, we'll explore the fundamentals and advanced patterns that make hooks so powerful.</p><h2>What are React Hooks?</h2><p>Hooks are functions that allow you to \"hook into\" React state and lifecycle features from function components. They provide a way to use state, context, refs, and effects without classes.</p><h2>Basic Hooks</h2><h3>useState</h3><p>The most fundamental hook for managing local state:</p><pre><code class=\"language-javascript\">import React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}</code></pre><h3>useEffect</h3><p>Handles side effects in functional components:</p><pre><code class=\"language-javascript\">import React, { useState, useEffect } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  }, [count]); // Only re-run if count changes\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}</code></pre><h2>Advanced Hook Patterns</h2><h3>Custom Hooks</h3><p>Custom hooks let you extract component logic into reusable functions:</p><pre><code class=\"language-javascript\">function useWindowSize() {\n  const [size, setSize] = useState({\n    width: window.innerWidth,\n    height: window.innerHeight\n  });\n\n  useEffect(() => {\n    const handleResize = () => {\n      setSize({\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    };\n\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  return size;\n}\n\n// Usage\nfunction MyComponent() {\n  const size = useWindowSize();\n  return <div>Window size: {size.width} x {size.height}</div>;\n}</code></pre><h3>useReducer for Complex State</h3><p>For complex state logic, useReducer provides a more predictable way to manage state:</p><pre><code class=\"language-javascript\">const initialState = { count: 0 };\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return { count: state.count + 1 };\n    case 'decrement':\n      return { count: state.count - 1 };\n    case 'reset':\n      return { count: 0 };\n    default:\n      throw new Error();\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  \n  return (\n    <div>\n      Count: {state.count}\n      <button onClick={() => dispatch({ type: 'increment' })}>+</button>\n      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>\n      <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>\n    </div>\n  );\n}</code></pre><h2>Performance Optimization</h2><h3>useMemo and useCallback</h3><p>These hooks help optimize performance by memoizing values and functions:</p><pre><code class=\"language-javascript\">import React, { useState, useMemo, useCallback } from 'react';\n\nfunction ExpensiveComponent({ items, onItemClick }) {\n  // Memoize expensive calculation\n  const expensiveValue = useMemo(() => {\n    return items.reduce((acc, item) => acc + item.value, 0);\n  }, [items]);\n\n  // Memoize callback function\n  const handleClick = useCallback((item) => {\n    onItemClick(item);\n  }, [onItemClick]);\n\n  return (\n    <div>\n      <p>Expensive value: {expensiveValue}</p>\n      {items.map(item => (\n        <button key={item.id} onClick={() => handleClick(item)}>\n          {item.name}\n        </button>\n      ))}\n    </div>\n  );\n}</code></pre><h2>Common Pitfalls and Best Practices</h2><ul><li><strong>Dependency Arrays:</strong> Always include all dependencies in useEffect dependency arrays</li><li><strong>Cleanup:</strong> Return cleanup functions from useEffect to prevent memory leaks</li><li><strong>Hook Rules:</strong> Only call hooks at the top level of your component</li><li><strong>State Updates:</strong> Use functional updates when new state depends on old state</li></ul><h2>Conclusion</h2><p>React Hooks have fundamentally changed how we write React components. They provide a more intuitive way to manage state and side effects while promoting better code organization and reusability. By understanding the patterns and best practices, you can write more maintainable and performant React applications.</p><p>Remember, hooks are not just a new API—they represent a new way of thinking about React components and state management. Embrace the functional paradigm and enjoy the benefits of cleaner, more readable code!</p>"
  }
]
